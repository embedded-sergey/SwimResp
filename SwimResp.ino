////////////////////
// USER INTERFACE //
////////////////////

// Set the measurement and flush phases (in seconds)
unsigned long FLUSH = 0;
unsigned long MEASUREMENT = 1000;

// Speed (e.g. cm/s) and length (in seconds) of increment steps 
// of the Ucrit protocol (typically, the have similar length)
float SPEED[] = {5, 10, 15, 17.5, 20, 
                 22.5, 25, 27.5, 30, 32.5, 
                 35, 37.5, 40, 45, 50}; 

unsigned int LENGTH[] = {10, 10, 10, 10, 10, 
                10, 10, 10, 10, 10, 
                10, 10, 10, 10, 10};

// Motor calibration (the arrays should have increasing values)
float in[]  = {5, 50}; // in cm/s
float out[] = {15, 33}; // raw data: 0...255



/////////////////////////
// IMPLEMENTATION CODE //
/////////////////////////
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

// pinout map
const byte PICO_RX = 2; // DO meter
const byte PICO_TX = 3; // DO meter
const byte LED = 4;
const byte enA = 5; // PWM for a motor
const byte in1 = 6; // motor
const byte in2 = 7; // motor
const byte in3 = 8; // pump
const byte in4 = 9; // pump
const byte enB = 10; // PWM for a pump
const byte BUTTON_GREEN = 11;
const byte BUTTON_RED = 12;
const byte I2C_CLOCK = A4; // display
const byte I2C_DATA = A5; // display

// buttons
long buttonTimer = 0;
long buttonTime = 1000;
boolean buttonActive = false;
boolean longPressActive = false;
boolean button1Active = false;
boolean button2Active = false;
boolean reverseMotor1 = false; //motor IN1
boolean reverseMotor2 = true; //motor IN2

// motor & pump
int PERIOD = 1;
unsigned long TIMER;
int i = 0;
unsigned long previousTime_pump = 0;
unsigned long previousTime_measurement = 0;
unsigned long previousTime_motor = 0;
unsigned long previousTime_display = 0;

// i2c dislpay
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET    -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const unsigned char myBitmapMaker [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x97, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf9, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x6f, 0x6c, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x97, 0x9f, 0x5f, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf6, 0xb7, 0x73, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x6f, 0x6c, 0xbe, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0x79, 0x7f, 0xad, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7b, 0x9e, 0x73, 0x7b, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf6, 0xcd, 0xde, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xdf, 0xda, 0xfe, 0xe6, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0x7e, 0x7a, 0xf3, 0xb9, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xfb, 0xcf, 0xb0, 0xb6, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbd, 0xbc, 0xd8, 0x07, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xd9, 0x82, 0xf6, 0xd7, 0xd7, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 0xff, 0x6e, 0xf0, 0x5f, 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x75, 0xda, 0x6f, 0xb2, 0xac, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xde, 0xdb, 0x6e, 0x7e, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xb3, 0xbf, 0x37, 0xcc, 0x5b, 0x7f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfd, 0xad, 0xbe, 0xe5, 0xb1, 0xf4, 0x9b, 0xbf, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfd, 0xb6, 0xee, 0xfd, 0x9e, 0x33, 0x3e, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfa, 0xdb, 0xbb, 0x9e, 0xce, 0xca, 0x66, 0xdf, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfb, 0xce, 0xed, 0xf3, 0xf3, 0xf8, 0xfd, 0xbf, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xf7, 0xdb, 0xb7, 0x6e, 0x78, 0x03, 0x9d, 0xaf, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xf6, 0x37, 0x7c, 0x01, 0xcf, 0xff, 0x77, 0xef, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xed, 0xad, 0xc7, 0xff, 0x1d, 0xb6, 0xec, 0xd7, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xef, 0xf6, 0x3f, 0xff, 0xf3, 0x7b, 0xbf, 0xb7, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xfa, 0x74, 0xfe, 0xf7, 0xfc, 0xcf, 0x73, 0xbf, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xdb, 0xcb, 0x0d, 0x5f, 0x7f, 0xb9, 0xde, 0xeb, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xdf, 0x6f, 0x36, 0xad, 0xef, 0xcf, 0xb0, 0x6f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xed, 0x9e, 0x17, 0x57, 0xff, 0x76, 0xcf, 0x9b, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xb6, 0xbe, 0x57, 0x57, 0xdd, 0xf9, 0x3f, 0xd9, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xb7, 0xdb, 0x3f, 0x57, 0x7f, 0xfe, 0xff, 0x7d, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xdd, 0x4f, 0x0f, 0x77, 0xfb, 0xd9, 0x3b, 0xcf, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xf7, 0x77, 0xfd, 0xbf, 0xef, 0x67, 0xdf, 0xdb, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xb7, 0xb5, 0xfe, 0xaf, 0x7f, 0x9a, 0xc7, 0xf7, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xbc, 0xec, 0x79, 0x5d, 0xfc, 0xde, 0xf9, 0xac, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x6f, 0xbb, 0x9f, 0xff, 0xe3, 0x77, 0xb6, 0x3e, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x73, 0xbe, 0xd0, 0xf8, 0x1f, 0x6d, 0xbe, 0xf2, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xbe, 0xe7, 0x77, 0x2e, 0xf5, 0xee, 0xeb, 0x9e, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xad, 0xbd, 0xdd, 0xf7, 0xb7, 0x3b, 0xbb, 0xf6, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x7b, 0xdb, 0xbb, 0xdd, 0xdd, 0xed, 0xde, 0x76, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x92, 0x4a, 0x66, 0x24, 0x49, 0x24, 0x45, 0x98, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x84, 0x20, 0x40, 0x82, 0x22, 0x13, 0x20, 0x02, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0x29, 0x97, 0x19, 0x39, 0x94, 0xc8, 0x9a, 0xc8, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc0, 0x03, 0xfc, 0x7e, 0x43, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc4, 0xe7, 0xfc, 0x7e, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xd2, 0x7f, 0xbc, 0xfe, 0xac, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xcf, 0xc6, 0x0c, 0x06, 0x38, 0xc1, 0x81, 0x01, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc0, 0x46, 0x4d, 0x22, 0x72, 0x88, 0x99, 0x10, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xd2, 0x56, 0x39, 0xca, 0x85, 0x9a, 0x9f, 0x58, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc8, 0xc7, 0x38, 0x62, 0x23, 0x22, 0xc3, 0x3a, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xcf, 0xcf, 0x8a, 0xe2, 0x6b, 0x3f, 0xe1, 0x39, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc7, 0xcc, 0x8a, 0xee, 0xb1, 0x80, 0x99, 0x04, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xd7, 0xc4, 0x68, 0xc2, 0x35, 0x91, 0x87, 0x45, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xc7, 0xc6, 0x38, 0xc6, 0x30, 0xe1, 0x87, 0x13, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff
      };

void setup(){

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for (;;); // Don't proceed, loop forever
  }
  display.clearDisplay();
  // Draw the bitmap:
  // drawBitmap(x position, y position, bitmap data, bitmap width, bitmap height, color)
  display.drawBitmap(0, 0, myBitmapMaker, 128, 64, WHITE);
  display.display();
  delay(3000); // Pause for 3 seconds
  // Clear the buffer
  display.clearDisplay();


  pinMode(LED, OUTPUT);

  // Button setup
  pinMode(BUTTON_GREEN, INPUT_PULLUP);
  pinMode(BUTTON_RED, INPUT_PULLUP);

  // Set all the motor control pins to outputs
  pinMode(enA, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  // Turn on motors
  digitalWrite(in1, LOW);
  digitalWrite(in2, HIGH);  
  digitalWrite(in3, LOW);
  digitalWrite(in4, HIGH);

  // Kick starter for the motor
  analogWrite(enA, 255);
  delay(20);
  
  Serial.begin(9600);
}

void loop(){
  pumpControl(); // to control a pump
  motorControl(); // to regulate motor speed
  displayUpdate();
  buttonEvents(); // to identify button actions
}

void displayUpdate() {
  unsigned long currentTime_display = millis();
  if(currentTime_display - previousTime_display > 1000UL){
    display.clearDisplay();
    display.setTextColor(WHITE);
    
    // main info about the current interval of Ucrit
    display.setTextSize(2);
    display.setCursor(0, 2);
    display.print("Velocity");
    display.setCursor(0, 28);
    display.setTextSize(2);
    display.print(SPEED[i]);
    display.setTextSize(1);
    display.print(" cm/s");

    display.setCursor(77, 41);
    display.print("M22");
    if(reverseMotor1 == true){
      display.setCursor(66, 41);
      display.print("R");
    }

    display.setCursor(101, 47);
    display.print("NOW");
    display.setCursor(101, 57);
    display.print(LENGTH[i]);
    display.print("s");
    int percent_bar = (100*TIMER)/LENGTH[i];
    for(int k = 5; k < 99; k = k+10){
      display.drawLine(k, 53, k, 62, WHITE);
    }
    display.drawRect(0, 53, 96, 10, WHITE);
    display.fillRect(0, 53, percent_bar, 10, WHITE);


    // info module for the next interval of Ucrit
    display.setCursor(101, 3);
    display.print("NEXT");
    display.setCursor(101, 13);
    display.print("600s");
    display.setCursor(101, 23);
    display.print("12.0");
    display.setCursor(101, 33);
    display.print("cm/s");
    display.drawRect(98, 0, 29, 43, WHITE);

    display.display();
    previousTime_display = currentTime_display;
    }
  }

void pumpControl(){
  unsigned long currentTime_pump = millis();

  if(currentTime_pump - previousTime_pump <= FLUSH*1000UL){
   // set pin 3 OFF to turn off the relay,
    analogWrite(enB, 255);   // so pumps start working again.
    digitalWrite(LED, HIGH);
  }

  else if(currentTime_pump - previousTime_pump > FLUSH*1000UL && 
          currentTime_pump - previousTime_pump <= MEASUREMENT*1000UL 
                                                    + FLUSH*1000UL){
    digitalWrite(enB, 0); // set pin 3 ON to activate the relay,
                               // so pumps stop working
    // blinking LED during Measurement Phase
      if(currentTime_pump % 1000UL <= 800UL){
        digitalWrite(LED, LOW);
      }
      else{
        digitalWrite(LED, HIGH);
      }
  }

  else{
    previousTime_pump = currentTime_pump;
    PERIOD++;
  }
}

void motorControl(){
  // map actual values (cm/s) to raw (bits 0...255)
  float raw = FmultiMap(SPEED[i], in, out, sizeof in/sizeof *in);

  unsigned long currentTime_motor = millis();
  if(currentTime_motor - previousTime_motor <= LENGTH[i]*1000UL){
    analogWrite(enA, raw);
    TIMER = (currentTime_motor - previousTime_motor)/1000UL;
  }
  else{
    i++;
    previousTime_motor = currentTime_motor;
  }
  
  // Number of elements in an array
  if(i >= sizeof LENGTH/sizeof *LENGTH){
    i = 0;
  }
}

void buttonEvents(){
  // note, the logic is inversed here due to an internal pull-up resistor
  if (digitalRead(BUTTON_GREEN) != HIGH) {
		if (buttonActive == false) {
			buttonActive = true;
			buttonTimer = millis();
		}
    button1Active = true;
	}

	if (digitalRead(BUTTON_RED) != HIGH) {
		if (buttonActive == false) {
			buttonActive = true;
			buttonTimer = millis();
		}
		button2Active = true;
	}
  delay(50);

	if ((buttonActive == true) && (digitalRead(BUTTON_GREEN) != LOW) && (digitalRead(BUTTON_RED) != LOW)) {
		if(longPressActive == true) {
			longPressActive = false;
		} 
    else{
			if((button1Active == true) && (button2Active == true)) {
				Serial.println("Short press custom mode: programm it yourself");
        } 
      else if((button1Active == true) && (button2Active == false)) {
		  // CASE1: short press -> reverse motor for a several seconds
        unsigned long previousTime_motor = millis();
        TIMER = 0;
        i = i - 1;
        }
			else if((button1Active == false) && (button2Active == true)) {
		  // CASE2: short press -> reverse motor for a several seconds
        unsigned long previousTime_motor = millis();
        TIMER = 0;
        i = i + 1;
			}
      else{
      }
		}
		buttonActive = false;
		button1Active = false;
		button2Active = false;
	}

  if ((buttonActive == true) && (millis() - buttonTimer > buttonTime) && (longPressActive == false)) {
		longPressActive = true;
		if ((button1Active == true) && (button2Active == true)) {
			Serial.println("Long press custom mode: programm it yourself");
      }
		else if((button1Active == true) && (button2Active == false)) {
      // CASE3: long press -> reverse motor
      reverseMotor1 = !reverseMotor1; //motor IN1
      reverseMotor2 = !reverseMotor2; //motor IN2
      for (int j = SPEED[i]; j >= 0; j = j-10){  //soft reverse
          analogWrite(enA, j);
          delay(5);
        }
      digitalWrite(in1, reverseMotor1);
      digitalWrite(in2, reverseMotor2);

      analogWrite(enA, 123);
      delay(50);
      }
    else if((button1Active == false) && (button2Active == true)) {
      // CASE4: long press -> 2.5 hour pause
      for (int j = SPEED[i]; j >= SPEED[0]; j = j-1){  //soft reverse
        analogWrite(enA, j);
        delay(20);
        }
      i = 0;
      SPEED[0] = {5};
      LENGTH[0] = {9999};
      }
		else{
		}
	}
}



// Originally from: https://playground.arduino.cc/Main/MultiMap
float FmultiMap(float val, float * _in, float * _out, uint8_t size){
  // take care the value is within range
  // val = constrain(val, _in[0], _in[size-1]);
  if (val <= _in[0]) return _out[0];
  if (val >= _in[size-1]) return _out[size-1];

  // search right interval
  uint8_t pos = 1;  // _in[0] allready tested
  while(val > _in[pos]) pos++;

  // this will handle all exact "points" in the _in array
  if (val == _in[pos]) return _out[pos];

  // interpolate in the right segment for the rest
  return (val - _in[pos-1]) * (_out[pos] - _out[pos-1]) / 
          (_in[pos] - _in[pos-1]) + _out[pos-1];
}


// Voltage values?
// Remove units
// connect to DAQ-PLX2
// form a nice table
// have a nice graph


/*for (int i = 30; i < 40; i++)
  {
    analogWrite(enA, i);
    analogWrite(enB, i);
    delay(1000);
  } 
  
  // Decelerate from maximum speed to zero

 
  // Now turn off motors
  digitalWrite(in1, LOW);
  digitalWrite(in2, LOW);  
  digitalWrite(in3, LOW);
  digitalWrite(in4, LOW);  
}*/

/* REFERENCES:
1. L298n: https://dronebotworkshop.com/dc-motors-l298n-h-bridge/
2. Multimap: https://playground.arduino.cc/Main/MultiMap/
3. Buttons: https://www.instructables.com/Arduino-Dual-Function-Button-Long-PressShort-Press/
   (a mistake in schematics: the orange wire should be in line #5)
4. Event-based programming: ... //// ADD HERE!
*/

