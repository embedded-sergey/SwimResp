////////////////////
// USER INTERFACE //
////////////////////

// Set the measurement and flush phases (in seconds)
unsigned long FLUSH = 20;
unsigned long MEASUREMENT = 5;

// Speed (e.g. cm/s) and length (in seconds) of increment steps 
// of the Ucrit protocol (typically, the have similar length)
float SPEED[] = {5, 10, 15, 17.5, 20, 
                 22.5, 25, 27.5, 30, 32.5, 
                 35, 37.5, 40, 45, 50}; 

int LENGTH[] = {60, 10, 10, 10, 10, 
                10, 10, 10, 10, 10, 
                10, 10, 10, 10, 10};

// Motor calibration (the arrays should have increasing values)
float in[]  = {5, 50}; // in cm/s
float out[] = {15, 33}; // raw data: 0...255



/////////////////////////
// IMPLEMENTATION CODE //
/////////////////////////
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

const byte PICO_RX = 2;
const byte PICO_TX = 3;
const byte LED = 4;

// Pinout for L298n controlling swimm-tunnels #1 and #2 
const byte enA = 5; // PWM for a motor
const byte in1 = 6;
const byte in2 = 7;
const byte in3 = 8;
const byte in4 = 9;
const byte enB = 10; // PWM for a pump

const byte BUTTON_REVERSE = 11; // longpress to step down in Ucrit
const byte BUTTON_STOP = 12;    // longpress to step up in Ucrit

const byte I2C_CLOCK = A4; // display
const byte I2C_DATA = A5; // display

int PERIOD = 1;
unsigned long TIMER;
int i = 0;

const byte button = A2;
const byte LED_TEST = A3; /// only fore testing *REMOVE
boolean LED_TEST_State = false; /// only fore testing *REMOVE
boolean buttonActive = false;
boolean longPressActive = false;
long buttonTimer = 0; /// MOVE TO the section 'Time variables'
long longPressTime = 3000; /// MOVE TO the section 'Time variables'

#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels
#define OLED_RESET    -1 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// Time variables
unsigned long previousTime_pump = 0;
unsigned long previousTime_measurement = 0;
unsigned long previousTime_motor = 0;
unsigned long previousTime_display = 0;

const unsigned char myBitmapMaker [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x97, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x07, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xf9, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x6f, 0x6c, 0x73, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x97, 0x9f, 0x5f, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xf6, 0xb7, 0x73, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf7, 0x6f, 0x6c, 0xbe, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xdb, 0x79, 0x7f, 0xad, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7b, 0x9e, 0x73, 0x7b, 0xaf, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfc, 0xf6, 0xcd, 0xde, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xdf, 0xda, 0xfe, 0xe6, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0x7e, 0x7a, 0xf3, 0xb9, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xfb, 0xcf, 0xb0, 0xb6, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xef, 0xbd, 0xbc, 0xd8, 0x07, 0x5f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xd9, 0x82, 0xf6, 0xd7, 0xd7, 0x67, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xbd, 0xff, 0x6e, 0xf0, 0x5f, 0xed, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x7e, 0x75, 0xda, 0x6f, 0xb2, 0xac, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0xde, 0xdb, 0x6e, 0x7e, 0xcf, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xfd, 0xb3, 0xbf, 0x37, 0xcc, 0x5b, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfd, 0xad, 0xbe, 0xe5, 0xb1, 0xf4, 0x9b, 0xbf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfd, 0xb6, 0xee, 0xfd, 0x9e, 0x33, 0x3e, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfa, 0xdb, 0xbb, 0x9e, 0xce, 0xca, 0x66, 0xdf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfb, 0xce, 0xed, 0xf3, 0xf3, 0xf8, 0xfd, 0xbf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf7, 0xdb, 0xb7, 0x6e, 0x78, 0x03, 0x9d, 0xaf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf6, 0x37, 0x7c, 0x01, 0xcf, 0xff, 0x77, 0xef, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xed, 0xad, 0xc7, 0xff, 0x1d, 0xb6, 0xec, 0xd7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xef, 0xf6, 0x3f, 0xff, 0xf3, 0x7b, 0xbf, 0xb7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xfa, 0x74, 0xfe, 0xf7, 0xfc, 0xcf, 0x73, 0xbf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xdb, 0xcb, 0x0d, 0x5f, 0x7f, 0xb9, 0xde, 0xeb, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xdf, 0x6f, 0x36, 0xad, 0xef, 0xcf, 0xb0, 0x6f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xed, 0x9e, 0x17, 0x57, 0xff, 0x76, 0xcf, 0x9b, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xb6, 0xbe, 0x57, 0x57, 0xdd, 0xf9, 0x3f, 0xd9, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xb7, 0xdb, 0x3f, 0x57, 0x7f, 0xfe, 0xff, 0x7d, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xdd, 0x4f, 0x0f, 0x77, 0xfb, 0xd9, 0x3b, 0xcf, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf7, 0x77, 0xfd, 0xbf, 0xef, 0x67, 0xdf, 0xdb, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xb7, 0xb5, 0xfe, 0xaf, 0x7f, 0x9a, 0xc7, 0xf7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xbc, 0xec, 0x79, 0x5d, 0xfc, 0xde, 0xf9, 0xac, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x6f, 0xbb, 0x9f, 0xff, 0xe3, 0x77, 0xb6, 0x3e, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x73, 0xbe, 0xd0, 0xf8, 0x1f, 0x6d, 0xbe, 0xf2, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xbe, 0xe7, 0x77, 0x2e, 0xf5, 0xee, 0xeb, 0x9e, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xad, 0xbd, 0xdd, 0xf7, 0xb7, 0x3b, 0xbb, 0xf6, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7b, 0xdb, 0xbb, 0xdd, 0xdd, 0xed, 0xde, 0x76, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x92, 0x4a, 0x66, 0x24, 0x49, 0x24, 0x45, 0x98, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x84, 0x20, 0x40, 0x82, 0x22, 0x13, 0x20, 0x02, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x29, 0x97, 0x19, 0x39, 0x94, 0xc8, 0x9a, 0xc8, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x03, 0xfc, 0x7e, 0x43, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc4, 0xe7, 0xfc, 0x7e, 0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xd2, 0x7f, 0xbc, 0xfe, 0xac, 0xff, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xcf, 0xc6, 0x0c, 0x06, 0x38, 0xc1, 0x81, 0x01, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc0, 0x46, 0x4d, 0x22, 0x72, 0x88, 0x99, 0x10, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xd2, 0x56, 0x39, 0xca, 0x85, 0x9a, 0x9f, 0x58, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc8, 0xc7, 0x38, 0x62, 0x23, 0x22, 0xc3, 0x3a, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xcf, 0xcf, 0x8a, 0xe2, 0x6b, 0x3f, 0xe1, 0x39, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc7, 0xcc, 0x8a, 0xee, 0xb1, 0x80, 0x99, 0x04, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xd7, 0xc4, 0x68, 0xc2, 0x35, 0x91, 0x87, 0x45, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc7, 0xc6, 0x38, 0xc6, 0x30, 0xe1, 0x87, 0x13, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff
      };

void setup(){

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64
    Serial.println(F("SSD1306 allocation failed"));
    for (;;); // Don't proceed, loop forever
  }
  display.clearDisplay();
  // Draw the bitmap:
  // drawBitmap(x position, y position, bitmap data, bitmap width, bitmap height, color)
  display.drawBitmap(0, 0, myBitmapMaker, 128, 64, WHITE);
  display.display();
  delay(3000); // Pause for 3 seconds
  // Clear the buffer
  display.clearDisplay();


  pinMode(LED, OUTPUT);

  // Button setup
  pinMode(LED_TEST, OUTPUT);
  pinMode(button, INPUT);

  // Set all the motor control pins to outputs
  pinMode(enA, OUTPUT);
  pinMode(enB, OUTPUT);
  pinMode(in1, OUTPUT);
  pinMode(in2, OUTPUT);
  pinMode(in3, OUTPUT);
  pinMode(in4, OUTPUT);
  
  // Turn on motors
  digitalWrite(in1, LOW);
  digitalWrite(in2, HIGH);  
  digitalWrite(in3, LOW);
  digitalWrite(in4, HIGH);

  // Starter for a motor
  analogWrite(enA, 255);
  delay(20);
  
  Serial.begin(9600);
}

void loop(){
  pumpControl(); // to control a pump
  motorControl(); // to regulate motor speed
  displayTemp();
  //buttonEvents(); // to identify button actions
}

void displayTemp() {
  unsigned long currentTime_display = millis();
  if(currentTime_display - previousTime_display > 1000UL){
    display.clearDisplay();
    display.setTextColor(WHITE);
    
    // main info about the current interval of Ucrit
    display.setTextSize(2);
    display.setCursor(0, 2);
    display.print("Velocity");
    display.setCursor(0, 28);
    display.setTextSize(2);
    display.print(SPEED[i]);
    display.setTextSize(1);
    display.print(" cm/s");

    display.setCursor(77, 41);
    display.print("M22");
    display.setCursor(101, 2);

    display.setCursor(101, 47);
    display.print("NOW");
    display.setCursor(101, 57);
    display.print(LENGTH[i]);
    display.print("s");
    int percent_bar = (100*TIMER)/LENGTH[i];

    for(int k = 5; k < 99; k = k+10){
      display.drawLine(k, 53, k, 62, WHITE);
    }
    display.drawRect(0, 53, 96, 10, WHITE);
    display.fillRect(0, 53, percent_bar, 10, WHITE);


    // info module for the next interval of Ucrit
    display.setCursor(101, 3);
    display.print("NEXT");
    display.setCursor(101, 13);
    display.print("600s");
    display.setCursor(101, 23);
    display.print("12.0");
    display.setCursor(101, 33);
    display.print("cm/s");
    display.drawRect(98, 0, 29, 43, WHITE);

    display.display();
    previousTime_display = currentTime_display;
    }
  }

void pumpControl(){
  unsigned long currentTime_pump = millis();

  if(currentTime_pump - previousTime_pump <= FLUSH*1000UL){
   // set pin 3 OFF to turn off the relay,
    analogWrite(enB, 255);   // so pumps start working again.
    digitalWrite(LED, HIGH);
  }

  else if(currentTime_pump - previousTime_pump > FLUSH*1000UL && 
          currentTime_pump - previousTime_pump <= MEASUREMENT*1000UL 
                                                    + FLUSH*1000UL){
    digitalWrite(enB, 0); // set pin 3 ON to activate the relay,
                               // so pumps stop working
    // blinking LED during Measurement Phase
      if(currentTime_pump % 1000UL <= 800UL){
        digitalWrite(LED, LOW);
      }
      else{
        digitalWrite(LED, HIGH);
      }
  }

  else{
    previousTime_pump = currentTime_pump;
    PERIOD++;
  }
}

void motorControl(){
  // map actual values (cm/s) to raw (bits 0...255)
  float raw = FmultiMap(SPEED[i], in, out, sizeof in/sizeof *in);
  Serial.print(SPEED[i]);
  Serial.print(" cm/s\t");
  Serial.print(raw);
  Serial.println(" bits");

  // kind of for loop
  unsigned long currentTime_motor = millis();
  if(currentTime_motor - previousTime_motor <= LENGTH[i]*1000UL){
    analogWrite(enA, raw);
    TIMER = (currentTime_motor - previousTime_motor)/1000UL;
  }
  else{
    i++;
    previousTime_motor = currentTime_motor;
  }
  
  // Number of elements in an array
  if(i >= sizeof LENGTH/sizeof *LENGTH){
    i = 0;
  }
}

void buttonEvents(){
  if(digitalRead(button) == true){
    if (buttonActive == false) {
      buttonActive = true;
      buttonTimer = millis();
    }
      
    if((millis() - buttonTimer) > longPressTime && longPressActive == false){
      longPressActive == true;
      // CASE1: long press -> minimum value in the Ucrit protocol
      digitalWrite(in1, LOW);
      digitalWrite(in2, LOW);  
      digitalWrite(in3, LOW);
      digitalWrite(in4, LOW); 
    }
    
    else{
      // CASE2: short press -> reverse motor for a several seconds
      digitalWrite(LED_TEST, true);
    }
    
  }
  else{
    if (buttonActive == true) {
      buttonActive = false;
    }
    
    if (longPressActive == true) {
      longPressActive = false;
    }
    else {
      // CASE3: no press -> Ucrit protocol is running normally
      digitalWrite(LED_TEST, false);
    }
  }
}

// Voltage values?
// Remove units
// connect to DAQ-PLX2
// form a nice table
// have a nice graph

// Originally from: https://playground.arduino.cc/Main/MultiMap
float FmultiMap(float val, float * _in, float * _out, uint8_t size){
  // take care the value is within range
  // val = constrain(val, _in[0], _in[size-1]);
  if (val <= _in[0]) return _out[0];
  if (val >= _in[size-1]) return _out[size-1];

  // search right interval
  uint8_t pos = 1;  // _in[0] allready tested
  while(val > _in[pos]) pos++;

  // this will handle all exact "points" in the _in array
  if (val == _in[pos]) return _out[pos];

  // interpolate in the right segment for the rest
  return (val - _in[pos-1]) * (_out[pos] - _out[pos-1]) / 
          (_in[pos] - _in[pos-1]) + _out[pos-1];
}

/*for (int i = 30; i < 40; i++)
  {
    analogWrite(enA, i);
    analogWrite(enB, i);
    delay(1000);
  } 
  
  // Decelerate from maximum speed to zero
  for (int i = 40; i >= 30; --i)
  {
    analogWrite(enA, i);
    analogWrite(enB, i);
    delay(10);
  } 
 
  // Now turn off motors
  digitalWrite(in1, LOW);
  digitalWrite(in2, LOW);  
  digitalWrite(in3, LOW);
  digitalWrite(in4, LOW);  
}*/

// unsigned long SPEED[] = {75, 60, 75, 70, 60, 235, 255};
// unsigned long LENGTH[] = {20, 10, 20, 30, 80, 20, 20};

/* REFERENCES:
1. L298n: https://dronebotworkshop.com/dc-motors-l298n-h-bridge/
2. Multimap: https://playground.arduino.cc/Main/MultiMap/
3. Buttons: https://www.instructables.com/Arduino-Dual-Function-Button-Long-PressShort-Press/
   (a mistake in schematics: the orange wire should be in line #5)
4. Event-based programming: ... //// ADD HERE!
*/
